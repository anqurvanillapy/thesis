# Ideas

- 一些学士学位论文的想法及相关文档.  目前包括:
    + 论文信息
    + 操作系统实验课程的一些想法和见解

## 信息

- 题目: 基于参与者模型的异步框架及其 C++ 实现
- 指导老师: 戴红
- 关键词: 参与者模型, 事件循环, C++

## 背景

参与者模型 (actor model) 是一种经典的基于消息传递 (message passing)
并用于异步计算的数学模型, 基于参与者模型的著名编程语言有 Erlang, Elixir, Scala
(Akka 框架), Pony 等等, 其中前三者已属于工业级别, 可见于国内相关云计算, 游戏,
金融等需要承载高并发量的相关团队, 如云巴 (基于 Erlang 的云计算), 简悦 (Skynet
游戏框架) 等等.  C++ 中的参与者模型框架也有如 CAF 等成熟实现, 而我的目标就是使用
C++14 标准去实现基础的参与者模型运行时, 以及相应的异步 I/O 环境.

## 什么是参与者模型? (TL; DR)

参与者模型的讨论需要一份完整的数学表达, 在我深入学习之前, 我在此想以 OOP
作为论据对比并讨论参与者模型的特点.

OOP (面向对象程序设计) 其实隐含了一部分消息传递的思想,
但是一个对象的方法和成员封装过后, 在其他对象之间是以 *整体* 的方式来传递的,
也就是说 *数据* 及 *处理数据的方法* 在传递过程中造成了比较大的开销.

参与者 (actor) 类似一个含有 *静态方法* 及 *静态成员* 的类 (class),
但是它不能进行实例化 (instantiation), 它只能被相应的调度器 (scheduler) 所部署
(spawn).  一个参与者拥有一个 *收件箱* 和一个 *发件箱*, 并且有一个全局唯一的 ID
作为标识, 参与者只能通过确定指定 ID 的方式发送相关的消息 (message),
不能随机发送或主动进行广播等等 (虽然广播可用于 GC 的 quiescence 状态检查等工作,
但是这属于系统内部行为, 用户不能操控).  一个参与者拥有许多行为 (behavior),
类似 *类的静态方法*, 它用于匹配收件箱中的相应消息, 定义参与者的生命周期终止,
或者发送回应消息给指定的其他参与者, 又或者继续循环等待消息等等.
一个参与者的行为是可以在部署前由用户以多态的方式自定义的.

所以对比来看, 参与者的 *处理数据的方法* 是在调度器运作之后是固定不变的, 是
*相对静止* 的, 只关注 *数据* 的传递过程, 因而减少了相应的开销.

## 做这样的系统, 需要几个步骤?

三个, 它们是:

- 参与者类的设计与实现, 事关使用的便捷性等等
- 多线程调度器的设计与实现, 这是参与者模型的核心
- 异步 I/O 调度器的设计与实现, 将极大提高系统的实用程度

## 具体都有什么方法?

- 参与者的实现, 我目前完成的工作有
    + 基于协程 (coroutine) 的调度器, 调度算法为简单的 *先进先出* (FIFO),
    可以用于实现参与者类
    + 剩下为参与者行为的多态管理需要完成, 需要考察 静态/动态 两种多态方式
- 多线程参与者调度器的实现, 需要我完成
    + 系统初始参与者队列的工作分发 (job distribution)
    + 单线程内调度消息传递
    + 跨线程的消息传递
    + 空闲 (idle) 调度器的处理, 如工作窃取 (work stealing) 机制
- 异步 I/O 调度器的实现, 除了消息收发的处理, 还有
    + 事件循环机制的设计和实现, 这是核心
    + 事件监听器的设计, 如文件描述符监听器, 系统信号监听器等基本部件

## 那你做得完吗?  那你凭什么觉得你做得完?

可以.

- 我于大三寒假期间学习 C++, 并阅读了 Pony 的异步 I/O 源码, 了解 `epoll`/`kqueue`
等 Reactor 模型的高性能事件循环的机制, 能使用基本功能, 而我将做的系统则是设计
`epoll`/`kqueue` 等系统接口的公用 `traits`, 让用户调用便捷而不直接接触底层
- 我于大四上期间实现了 C++ 迷你协程库
[acoro](https://github.com/anqurvanillapy/acoro), 可改造成参与者类
- 我于近日阅读 [napajs](https://github.com/Microsoft/napajs) C++ 源码,
了解了多线程 V8 实例 (isolate) 的调度机制, 及其工作池 (worker pool) 的相应原理,
亲身实践了 *数据同步* 及 *工作分发* 的代码的编写, 还学习到了 C++14
一些新鲜的内存管理机制
- 我于近日阅读 [dasynq](https://github.com/davmac314/dasynq) C++ 源码,
这是个简易的事件循环 (event loop) 系统, 其作者用于编写仿 `systemd`/`init`
等子进程监听管理系统的后端环境, 其中我了解到了如 *文件描述符 单/双向 监听*,
*系统信号监听*, *子进程状态监听* 及 *计数器 (timer) 监听* 的设计和实现

另外, 我还能编写 Erlang, Elixir (前两者我写过 GenServer 的应用), Scala, Pony
这些语言的小型软件, 能吸收其他语言的实现精华.

## 这听起来是个大坑啊!

并不是的.  因为:

- 有大量的成功实现可以参考和阅读
- 工业级别的系统需要长时间的 benchmark, 我的系统和构想只是尝试,
不会进行深度优化及高强度的 benchmark, 符合基本需求和用户场景即可
- 系统将使用智能指针等特性管理内存块的生命周期, 不会涉及 GC 的涉及,
要么就可以搞一整年了 :)

## 有没有论文参考?

* [Pony 语言设计论文](https://www.ponylang.org/media/papers/a_string_of_ponies.pdf)
* [Pony 语言 GC 设计论文](https://www.ponylang.org/media/papers/OGC.pdf)

(有待未来添加.)

---

## 操作系统实验课平台的见解

我个人接触过 GNU GRUB 软件的使用 (系统镜像模拟器), 跟着这个
[教程](https://os.phil-opp.com/) 使用 Rust 语言 *半完成* 过一个简易操作系统,
到后面教程已经能支持 *堆内存申请* 以及 *段内存结构* 等功能.  我在 GNU GRUB
中虚拟了一台裸机 (bare metal) 并成功 boot 了这个操作系统.

初次之外, 我还了解到 MIT 使用 [xv6 OS](https://github.com/mit-pdos/xv6-public)
操作系统进行教学, 让其关键算法由学生完成, 比如进程调度等等.

我还了解到中山大学也是使用了类似教学操作系统 (teaching operating system)
进行上机实现, 这个我可以询问我的同学进行考察.

我个人对这个实验课平台的搭建也有一些兴趣, 虽然还是更想实现我自己论文的想法,
但是也想听听老师在这方面有什么样的见解.
